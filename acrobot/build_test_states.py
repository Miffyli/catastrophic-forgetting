#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
import numpy as np
import os
import sys
import warnings

from envs import Acrobot, AcrobotPrediction
from tools import *

# parse args
parser = argparse.ArgumentParser(
    description='This constructs a test set for an acrobot prediction task.')
parser.add_argument(
    'outfile',
    type=str,
    help='npz file to dump states and returns; '
         'will terminate if file already exists')
parser.add_argument(
    'num_steps',
    type=int,
    help='length of trajectory to sample states from')
parser.add_argument(
    'sample_size',
    type=int,
    help='number of states to sample from trajectory')
parser.add_argument(
    '--trajectory-outfile',
    type=str,
    help='npy file to dump the trajectory the sample is taken from to; '
         'will terminate if this argument is specified but file already exists')
parser.add_argument(
    '--interference-outfile',
    type=str,
    help='npz file to dump states and returns for use in measuring catastrophic interference; '
         'will terminate if this argument is specified but file already exists')
parser.add_argument(
    '--interference-sample-size',
    type=int,
    help='number of states to sample for use in measuring catastrophic interference')
args = vars(parser.parse_args())

# check args
assert(0 < args['sample_size'] <= args['num_steps'])
if os.path.isfile(args['outfile']):
    warnings.warn('outfile already exists; terminating\n')
    sys.exit(0)
if args['trajectory_outfile'] is not None:
    if os.path.isfile(args['trajectory_outfile']):
        warnings.warn('trajectory outfile already exists; terminating\n')
        sys.exit(0)
if args['interference_outfile'] is not None:
    if os.path.isfile(args['interference_outfile']):
        warnings.warn('interference outfile already exists; terminating\n')
        sys.exit(0)
    assert('interference_sample_size' is not None)

SEED = 49192  # generated by RANDOM.ORG

# get trajectory
generator = np.random.RandomState(SEED)
env = AcrobotPrediction(generator=generator)

episodes = list()
returns = list()
while sum([len(episode) for episode in episodes]) < args['num_steps']:
    episodes.append([env.reset()])
    returns.append(list())
    done = False
    while not done:
        state, reward, done = env.step()
        if not done:
            episodes[- 1].append(state)
        returns[- 1].append(0)
        for i in range(len(returns[- 1])):
            returns[- 1][i] += reward
    assert(len(episodes[- 1]) == len(returns[- 1]))

# sample states from the trajectory
states = sum(episodes, [])[:args['num_steps']]
returns = sum(returns, [])[:args['num_steps']]
indices = generator.choice(len(states), args['sample_size'])
states = [states[i] for i in indices]
returns = [returns[i] for i in indices]

# get interference interference states if requested
if args['interference_outfile'] is not None:
    interference_states = list()
    interference_returns = list()
    interference_next_states = list()
    interference_next_returns = list()

    while len(interference_states) < args['interference_sample_size']:
        observation = np.random.rand(len(Acrobot.OBSERVATION_MIN))
        observation = scale(observation, 0, 1, Acrobot.OBSERVATION_MIN, Acrobot.OBSERVATION_MAX)
        env.set_state(observation)  # elements in observation depend on one another
        observation, _, done = env.step()
        if done:
            continue
        else:
            next_observation, reward, done = env.step()
            interference_states.append(observation)
            interference_next_states.append(next_observation)
            interference_next_returns.append(AcrobotPrediction.get_return(next_observation))
            interference_returns.append(reward + interference_next_returns[- 1])

# save arrays
np.savez(args['outfile'],
         x=states,
         y=returns)
if args['trajectory_outfile'] is not None:
    np.save(args['trajectory_outfile'],
            states)
if args['interference_outfile'] is not None:
    np.savez(args['interference_outfile'],
             x=interference_states,
             y=interference_returns,
             next_x=interference_next_states,
             next_y=interference_next_returns)
