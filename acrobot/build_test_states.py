#!/usr/bin/env python
# -*- coding: utf-8 -*-

from envs import AcrobotPrediction
import argparse
import numpy as np
import os
import warnings

# parse args
parser = argparse.ArgumentParser(
    description='This constructs a test set for an Acrobot prediction task.')
parser.add_argument(
    'outfile',
    type=str,
    help='npz file to dump states and returns; '
         'will terminate if file already exists')
parser.add_argument(
    'num_steps',
    type=int,
    help='length of trajectory to sample states from')
parser.add_argument(
    'sample_size',
    type=int,
    help='number of states to sample from trajectory')
parser.add_argument(
    '--trajectory-outfile',
    type=str,
    help='npy file to dump the trajectory the sample is taken from to; '
         'will terminate if this argument is specified but file already exists')
parser.add_argument(
    '--interference-outfile',
    type=str,
    help='npz file to dump states and returns for use in measuring catastrophic interference; '
         'will terminate if this argument is specified but file already exists')
parser.add_argument(
    '--interference-sample-size',
    type=int,
    help='number of states to sample for use in measuring catastrophic interference; '
         'required if interference outfile is specified')
args = vars(parser.parse_args())

# check args
assert(0 < args['sample_size'] <= args['num_steps'])
if os.path.isfile(args['outfile']):
    warnings.warn('outfile already exists; terminating\n')
    sys.exit(0)
if args['trajectory_outfile'] is not None:
    if os.path.isfile(args['trajectory_outfile']):
        warnings.warn('trajectory outfile already exists; terminating\n')
        sys.exit(0)
if args['interference_outfile'] is not None:
    if os.path.isfile(args['interference_outfile']):
        warnings.warn('interference outfile already exists; terminating\n')
        sys.exit(0)
    assert(args['interference_sample_size'] is not None)
else:
    assert(args['interference_sample_size'] is None)

SEED = 49192  # generated by RANDOM.ORG

# get trajectory
states = list()
generator = np.random.RandomState(SEED)
env = AcrobotPrediction(generator=generator)
done = True
while len(states) < args['num_steps']:
    if done:
        state = env.reset()
        done = False
    else:
        state, reward, done = env.step()
    if not done:
        states.append(state)

# sample states from the trajectory
indices = generator.choice(len(states), args['sample_size'])
sample = [states[i] for i in indices]

# get corresponding returns for states in the sample
returns = [AcrobotPrediction.get_return(i) for i in sample]

# get interference interference states if requested
def is_done(obs):
    return bool(- obs[0] - obs[2] * obs[0] - obs[3] * obs[1] > 1.)
if args['interference_outfile'] is not None:
    interference_states = list()
    interference_returns = list()
    for _ in range(args['interference_sample_size']):
        observation = env.get_random_observation()
        while is_done(observation):
            observation = env.get_random_observation()
        interference_states.append(observation)
        interference_returns.append(AcrobotPrediction.get_return(observation))

# save arrays
np.savez(args['outfile'],
         x=sample,
         y=returns)
if args['trajectory_outfile'] is not None:
    np.save(args['trajectory_outfile'],
            states)
if args['interference_outfile'] is not None:
    np.savez(args['interference_outfile'],
             x=interference_states,
             y=interference_returns)
